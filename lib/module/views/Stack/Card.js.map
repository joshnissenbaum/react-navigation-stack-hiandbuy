{"version":3,"sources":["Card.tsx"],"names":["React","View","I18nManager","StyleSheet","Platform","InteractionManager","Animated","PanGestureHandler","State","GestureState","memoize","StackGestureContext","PointerEventsView","TRUE","TRUE_NODE","Value","FALSE","FALSE_NODE","NOOP_NODE","UNSET","UNSET_NODE","MINUS_ONE_NODE","TOP","BOTTOM","DIRECTION_VERTICAL","DIRECTION_HORIZONTAL","GESTURE_VELOCITY_IMPACT","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","abs","add","block","call","cond","divide","eq","greaterThan","lessThan","max","min","multiply","neq","onChange","set","spring","sub","timing","startClock","stopClock","clockRunning","Clock","memoizedSpring","proc","springHelper","finished","velocity","position","time","prevPosition","toValue","damping","mass","stiffness","overshootClamping","restSpeedThreshold","restDisplacementThreshold","clock","state","config","transformSpringConfigToAnimatedValues","transformTimingConfigToAnimatedValues","duration","easing","Card","Component","props","gestureDirection","width","layout","height","gestureVelocityImpact","transitionSpec","open","animation","close","direction","current","interactionHandle","undefined","createInteractionHandle","clearInteractionHandle","handleEndInteraction","isRunningAnimation","interpolatedStyle","getInterpolatedStyle","styleInterpolator","index","next","insets","top","right","bottom","left","isVisible","openingSpec","closingSpec","didMovementHappen","handleStartInteraction","onTransitionStart","closing","handleTransitionEnd","onOpen","transitionVelocity","distance","frameTime","transitionState","value","noAnimationStartedSoFar","openingSpecConfig","closingSpecConfig","isSwipeGesture","gesture","isOpen","Boolean","onClose","gestureUntraversed","isRTL","velocityUntraversed","isClosing","nextIsVisible","exec","runTransition","isSwiping","isSwipeCancelled","onGestureBegin","onGestureEnd","onGestureCanceled","gestureState","ACTIVE","offset","target","CANCELLED","extrapolatedPosition","event","nativeEvent","translationX","velocityX","translationY","velocityY","insetTop","insetRight","insetBottom","insetLeft","progress","layouts","screen","createRef","componentDidUpdate","prevProps","setValue","verticalGestureDirection","requestAnimationFrame","componentWillUnmount","gestureActivationCriteria","gestureResponseDistance","vertical","horizontal","maxDeltaX","minOffsetY","hitSlop","minOffsetX","maxDeltaY","render","active","transparent","overlayEnabled","shadowEnabled","gestureEnabled","children","containerStyle","customContainerStyle","contentStyle","rest","cardStyle","overlayStyle","shadowStyle","overlayBackgroundComponent","handleGestureEvent","handleGestureEventVertical","handleGestureEventHorizontal","overrideFlex","style","flatten","hasOwnProperty","flex","gestureRef","execWithGesture","execNoGesture","styles","overlay","container","shadow","shadowHorizontal","shadowVertical","content","opaque","OS","create","overflow","absoluteFillObject","backgroundColor","shadowRadius","shadowColor","shadowOpacity","shadowOffset"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  View,\n  I18nManager,\n  StyleSheet,\n  ViewProps,\n  StyleProp,\n  ViewStyle,\n  Platform,\n  InteractionManager,\n} from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport {\n  PanGestureHandler,\n  State as GestureState,\n} from 'react-native-gesture-handler';\nimport { EdgeInsets } from 'react-native-safe-area-context';\nimport {\n  TransitionSpec,\n  CardStyleInterpolator,\n  Layout,\n  SpringConfig,\n  TimingConfig,\n} from '../../types';\nimport memoize from '../../utils/memoize';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport PointerEventsView from './PointerEventsView';\n\ntype Props = ViewProps & {\n  index: number;\n  active: boolean;\n  closing?: boolean;\n  transparent?: boolean;\n  next?: Animated.Node<number>;\n  current: Animated.Value<number>;\n  layout: Layout;\n  insets: EdgeInsets;\n  gestureDirection: 'horizontal' | 'vertical' | 'vertical-inverted';\n  onOpen: (isFinished: boolean) => void;\n  onClose: (isFinished: boolean) => void;\n  onTransitionStart?: (props: { closing: boolean }) => void;\n  onGestureBegin?: () => void;\n  onGestureCanceled?: () => void;\n  onGestureEnd?: () => void;\n  children: React.ReactNode;\n  overlayEnabled: boolean;\n  shadowEnabled: boolean;\n  gestureEnabled: boolean;\n  gestureResponseDistance?: {\n    vertical?: number;\n    horizontal?: number;\n  };\n  transitionSpec: {\n    open: TransitionSpec;\n    close: TransitionSpec;\n  };\n  styleInterpolator: CardStyleInterpolator;\n  gestureVelocityImpact: number;\n  containerStyle?: StyleProp<ViewStyle>;\n  contentStyle?: StyleProp<ViewStyle>;\n};\n\ntype AnimatedSpringConfig = {\n  damping: Animated.Value<number>;\n  mass: Animated.Value<number>;\n  stiffness: Animated.Value<number>;\n  restSpeedThreshold: Animated.Value<number>;\n  restDisplacementThreshold: Animated.Value<number>;\n  overshootClamping: Animated.Value<boolean>;\n};\n\nexport type AnimatedTimingConfig = {\n  duration: Animated.Value<number>;\n  easing: Animated.EasingFunction;\n};\n\ntype Binary = 0 | 1;\n\nconst TRUE = 1;\nconst TRUE_NODE = new Animated.Value(TRUE);\nconst FALSE = 0;\nconst FALSE_NODE = new Animated.Value(FALSE);\nconst NOOP_NODE = FALSE_NODE;\nconst UNSET = -1;\nconst UNSET_NODE = new Animated.Value(UNSET);\n\nconst MINUS_ONE_NODE = UNSET_NODE;\n\nconst TOP = -1;\nconst BOTTOM = 1;\n\nconst DIRECTION_VERTICAL = -1;\nconst DIRECTION_HORIZONTAL = 1;\n\nconst GESTURE_VELOCITY_IMPACT = 0.3;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst {\n  abs,\n  add,\n  block,\n  call,\n  cond,\n  divide,\n  eq,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  onChange,\n  set,\n  spring,\n  sub,\n  timing,\n  startClock,\n  stopClock,\n  clockRunning,\n  Clock,\n  Value,\n} = Animated;\n\n// We need to be prepared for both version of reanimated. With and w/out proc\nlet memoizedSpring = spring;\n// @ts-ignore\nif (Animated.proc) {\n  // @ts-ignore\n  const springHelper = Animated.proc(\n    (\n      finished: Animated.Value<number>,\n      velocity: Animated.Value<number>,\n      position: Animated.Value<number>,\n      time: Animated.Value<number>,\n      prevPosition: Animated.Value<number>,\n      toValue: Animated.Adaptable<number>,\n      damping: Animated.Adaptable<number>,\n      mass: Animated.Adaptable<number>,\n      stiffness: Animated.Adaptable<number>,\n      overshootClamping: Animated.Adaptable<boolean>,\n      restSpeedThreshold: Animated.Adaptable<number>,\n      restDisplacementThreshold: Animated.Adaptable<number>,\n      clock: Animated.Clock\n    ) =>\n      spring(\n        clock,\n        {\n          finished,\n          velocity,\n          position,\n          time,\n          // @ts-ignore\n          prevPosition,\n        },\n        {\n          toValue,\n          damping,\n          mass,\n          stiffness,\n          overshootClamping,\n          restDisplacementThreshold,\n          restSpeedThreshold,\n        }\n      )\n  );\n\n  // @ts-ignore\n  memoizedSpring = function(\n    clock: Animated.Clock,\n    state: {\n      finished: Animated.Value<number>;\n      velocity: Animated.Value<number>;\n      position: Animated.Value<number>;\n      time: Animated.Value<number>;\n    },\n    config: {\n      toValue: Animated.Adaptable<number>;\n      damping: Animated.Adaptable<number>;\n      mass: Animated.Adaptable<number>;\n      stiffness: Animated.Adaptable<number>;\n      overshootClamping: Animated.Adaptable<boolean>;\n      restSpeedThreshold: Animated.Adaptable<number>;\n      restDisplacementThreshold: Animated.Adaptable<number>;\n    }\n  ) {\n    return springHelper(\n      state.finished,\n      state.velocity,\n      state.position,\n      state.time,\n      new Value(0),\n      config.toValue,\n      config.damping,\n      config.mass,\n      config.stiffness,\n      config.overshootClamping,\n      config.restSpeedThreshold,\n      config.restDisplacementThreshold,\n      clock\n    );\n  };\n}\n\nfunction transformSpringConfigToAnimatedValues(\n  config: SpringConfig\n): AnimatedSpringConfig {\n  return {\n    damping: new Animated.Value(config.damping),\n    stiffness: new Animated.Value(config.stiffness),\n    mass: new Animated.Value(config.mass),\n    restDisplacementThreshold: new Animated.Value(\n      config.restDisplacementThreshold\n    ),\n    restSpeedThreshold: new Animated.Value(config.restSpeedThreshold),\n    overshootClamping: new Animated.Value(config.overshootClamping),\n  };\n}\n\nfunction transformTimingConfigToAnimatedValues(\n  config: TimingConfig\n): AnimatedTimingConfig {\n  return {\n    duration: new Animated.Value(config.duration),\n    easing: config.easing,\n  };\n}\n\nexport default class Card extends React.Component<Props> {\n  static defaultProps = {\n    overlayEnabled: Platform.OS !== 'ios',\n    shadowEnabled: true,\n    gestureEnabled: true,\n    gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,\n  };\n\n  componentDidUpdate(prevProps: Props) {\n    const {\n      layout,\n      gestureDirection,\n      closing,\n      gestureVelocityImpact,\n    } = this.props;\n    const { width, height } = layout;\n\n    if (width !== prevProps.layout.width) {\n      this.layout.width.setValue(width);\n    }\n\n    if (height !== prevProps.layout.height) {\n      this.layout.height.setValue(height);\n    }\n\n    if (gestureVelocityImpact !== prevProps.gestureVelocityImpact) {\n      this.gestureVelocityImpact.setValue(gestureVelocityImpact);\n    }\n\n    if (gestureDirection !== prevProps.gestureDirection) {\n      this.direction.setValue(\n        gestureDirection === 'vertical' ||\n          gestureDirection === 'vertical-inverted'\n          ? DIRECTION_VERTICAL\n          : DIRECTION_HORIZONTAL\n      );\n      this.verticalGestureDirection.setValue(\n        gestureDirection === 'vertical-inverted' ? TOP : BOTTOM\n      );\n    }\n\n    if (closing !== prevProps.closing) {\n      // If the style updates during render, setting the value here doesn't work\n      // We need to defer it a bit so the animation starts properly\n      requestAnimationFrame(() =>\n        requestAnimationFrame(() =>\n          this.isClosing.setValue(closing ? TRUE : FALSE)\n        )\n      );\n    }\n  }\n\n  componentWillUnmount(): void {\n    this.handleEndInteraction();\n\n    // It might sometimes happen than animation will be unmounted\n    // during running. However, we need to invoke listener onClose\n    // manually in this case\n    if (this.isRunningAnimation || this.noAnimationStartedSoFar) {\n      this.props.onClose(false);\n    }\n  }\n\n  private isVisible = new Value<Binary>(TRUE);\n  private nextIsVisible = new Value<Binary | -1>(UNSET);\n\n  private verticalGestureDirection = new Value(\n    this.props.gestureDirection === 'vertical-inverted' ? TOP : BOTTOM\n  );\n\n  private isClosing = new Value<Binary>(FALSE);\n  private noAnimationStartedSoFar = true;\n  private isRunningAnimation = false;\n\n  private clock = new Clock();\n\n  private direction = new Value(\n    this.props.gestureDirection === 'vertical' ||\n    this.props.gestureDirection === 'vertical-inverted'\n      ? DIRECTION_VERTICAL\n      : DIRECTION_HORIZONTAL\n  );\n\n  private layout = {\n    width: new Value(this.props.layout.width),\n    height: new Value(this.props.layout.height),\n  };\n\n  private gestureVelocityImpact = new Value<number>(\n    this.props.gestureVelocityImpact\n  );\n\n  private openingSpecConfig =\n    this.props.transitionSpec.open.animation === 'timing'\n      ? transformTimingConfigToAnimatedValues(\n          this.props.transitionSpec.open.config\n        )\n      : transformSpringConfigToAnimatedValues(\n          this.props.transitionSpec.open.config\n        );\n\n  private closingSpecConfig =\n    this.props.transitionSpec.close.animation === 'timing'\n      ? transformTimingConfigToAnimatedValues(\n          this.props.transitionSpec.close.config\n        )\n      : transformSpringConfigToAnimatedValues(\n          this.props.transitionSpec.close.config\n        );\n\n  private distance = cond(\n    eq(this.direction, DIRECTION_VERTICAL),\n    this.layout.height,\n    this.layout.width\n  );\n\n  private gestureUntraversed = new Value(0);\n  private gesture = new Value(0);\n  private offset = new Value(0);\n  private velocityUntraversed = new Value(0);\n  private velocity = new Value(0);\n  private didMovementHappen = new Value(0);\n\n  private gestureState = new Value(0);\n\n  private isSwiping = new Value(FALSE);\n  private isSwipeCancelled = new Value(FALSE);\n  private isSwipeGesture = new Value(FALSE);\n\n  private toValue = new Value(0);\n  private frameTime = new Value(0);\n\n  private transitionVelocity = new Value(0);\n\n  private transitionState = {\n    position: this.props.current,\n    time: new Value(0),\n    finished: new Value(FALSE),\n  };\n\n  private interactionHandle: number | undefined;\n\n  private handleStartInteraction = () => {\n    if (this.interactionHandle === undefined) {\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    }\n  };\n\n  private handleEndInteraction = () => {\n    if (this.interactionHandle !== undefined) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n      this.interactionHandle = undefined;\n    }\n  };\n\n  private handleTransitionEnd = () => {\n    this.handleEndInteraction();\n\n    this.isRunningAnimation = false;\n    this.interpolatedStyle = this.getInterpolatedStyle(\n      this.props.styleInterpolator,\n      this.props.index,\n      this.props.current,\n      this.props.next,\n      this.props.layout,\n      this.props.insets.top,\n      this.props.insets.right,\n      this.props.insets.bottom,\n      this.props.insets.left\n    );\n  };\n\n  private runTransition = (isVisible: Binary | Animated.Node<number>) => {\n    const { open: openingSpec, close: closingSpec } = this.props.transitionSpec;\n\n    return [\n      cond(\n        eq(this.props.current, isVisible),\n        call(\n          [this.didMovementHappen, this.isVisible],\n          ([didMovementHappen]: ReadonlyArray<Binary>) => {\n            if (didMovementHappen) {\n              // if we go back to the same position,\n              // let's pretend that whole animation happen\n              // for making the logic consistent\n              // It's especially vital for having inputs properly focused.\n              this.handleStartInteraction();\n              const { onTransitionStart } = this.props;\n              onTransitionStart && onTransitionStart({ closing: false });\n              this.handleTransitionEnd();\n              this.props.onOpen(true);\n            }\n          }\n        ),\n        [\n          cond(clockRunning(this.clock), NOOP_NODE, [\n            // Animation wasn't running before\n            // Set the initial values and start the clock\n            set(this.toValue, isVisible),\n            // The velocity value is ideal for translating the whole screen\n            // But since we have 0-1 scale, we need to adjust the velocity\n            set(\n              this.transitionVelocity,\n              multiply(\n                cond(\n                  this.distance,\n                  divide(this.velocity, this.distance),\n                  FALSE_NODE\n                ),\n                -1\n              )\n            ),\n            set(this.frameTime, FALSE_NODE),\n            set(this.transitionState.time, FALSE_NODE),\n            set(this.transitionState.finished, FALSE_NODE),\n            set(this.isVisible, isVisible),\n            startClock(this.clock),\n            call([this.isVisible], ([value]: ReadonlyArray<Binary>) => {\n              this.handleStartInteraction();\n\n              const { onTransitionStart } = this.props;\n              this.noAnimationStartedSoFar = false;\n              this.isRunningAnimation = true;\n              onTransitionStart && onTransitionStart({ closing: !value });\n            }),\n          ]),\n          cond(\n            eq(isVisible, TRUE_NODE),\n            openingSpec.animation === 'spring'\n              ? memoizedSpring(\n                  this.clock,\n                  {\n                    ...this.transitionState,\n                    velocity: this.transitionVelocity,\n                  },\n                  // @ts-ignore\n                  {\n                    ...(this.openingSpecConfig as AnimatedSpringConfig),\n                    toValue: this.toValue,\n                  }\n                )\n              : timing(\n                  this.clock,\n                  { ...this.transitionState, frameTime: this.frameTime },\n                  {\n                    ...(this.openingSpecConfig as AnimatedTimingConfig),\n                    toValue: this.toValue,\n                  }\n                ),\n            closingSpec.animation === 'spring'\n              ? memoizedSpring(\n                  this.clock,\n                  {\n                    ...this.transitionState,\n                    velocity: this.transitionVelocity,\n                  },\n                  // @ts-ignore\n                  {\n                    ...(this.closingSpecConfig as AnimatedSpringConfig),\n                    toValue: this.toValue,\n                  }\n                )\n              : timing(\n                  this.clock,\n                  { ...this.transitionState, frameTime: this.frameTime },\n                  {\n                    ...(this.closingSpecConfig as AnimatedTimingConfig),\n                    toValue: this.toValue,\n                  }\n                )\n          ),\n          cond(this.transitionState.finished, [\n            // Reset values\n            set(this.isSwipeGesture, FALSE_NODE),\n            set(this.gesture, FALSE_NODE),\n            set(this.velocity, FALSE_NODE),\n            // When the animation finishes, stop the clock\n            stopClock(this.clock),\n            call([this.isVisible], ([value]: ReadonlyArray<Binary>) => {\n              const isOpen = Boolean(value);\n              const { onOpen, onClose } = this.props;\n\n              this.handleTransitionEnd();\n\n              if (isOpen) {\n                onOpen(true);\n              } else {\n                onClose(true);\n              }\n            }),\n          ]),\n        ]\n      ),\n      set(this.didMovementHappen, 0),\n    ];\n  };\n\n  private extrapolatedPosition = add(\n    this.gesture,\n    multiply(this.velocity, this.gestureVelocityImpact)\n  );\n\n  private exec = [\n    set(\n      this.gesture,\n      cond(\n        eq(this.direction, DIRECTION_HORIZONTAL),\n        multiply(\n          this.gestureUntraversed,\n          I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n        ),\n        this.gestureUntraversed\n      )\n    ),\n    set(\n      this.velocity,\n      multiply(\n        this.velocityUntraversed,\n        I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n      )\n    ),\n    onChange(\n      this.isClosing,\n      cond(this.isClosing, set(this.nextIsVisible, FALSE_NODE))\n    ),\n    onChange(\n      this.nextIsVisible,\n      cond(neq(this.nextIsVisible, UNSET_NODE), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), [\n          call([], this.handleTransitionEnd),\n          stopClock(this.clock),\n        ]),\n        set(this.gesture, FALSE_NODE),\n        // Update the index to trigger the transition\n        set(this.isVisible, this.nextIsVisible),\n        set(this.nextIsVisible, UNSET_NODE),\n      ])\n    ),\n  ];\n\n  private execNoGesture = block([\n    ...this.exec,\n    this.runTransition(this.isVisible),\n  ]);\n\n  private execWithGesture = block([\n    ...this.exec,\n    onChange(\n      this.isSwiping,\n      call(\n        [this.isSwiping, this.isSwipeCancelled],\n        ([isSwiping, isSwipeCancelled]: readonly Binary[]) => {\n          const {\n            onGestureBegin,\n            onGestureEnd,\n            onGestureCanceled,\n          } = this.props;\n\n          if (isSwiping === TRUE) {\n            this.handleStartInteraction();\n\n            onGestureBegin && onGestureBegin();\n          } else {\n            this.handleEndInteraction();\n\n            if (isSwipeCancelled === TRUE) {\n              onGestureCanceled && onGestureCanceled();\n            } else {\n              onGestureEnd && onGestureEnd();\n            }\n          }\n        }\n      )\n    ),\n    onChange(this.gestureUntraversed, set(this.didMovementHappen, 1)),\n    cond(\n      eq(this.gestureState, GestureState.ACTIVE),\n      [\n        cond(this.isSwiping, NOOP_NODE, [\n          // We weren't dragging before, set it to true\n          set(this.isSwipeCancelled, FALSE_NODE),\n          set(this.isSwiping, TRUE_NODE),\n          set(this.isSwipeGesture, TRUE_NODE),\n          // Also update the drag offset to the last position\n          set(this.offset, this.props.current),\n        ]),\n        // Update position with next offset + gesture distance\n        set(\n          this.props.current,\n          min(\n            max(\n              sub(\n                this.offset,\n                cond(\n                  this.distance,\n                  divide(\n                    cond(\n                      eq(this.direction, DIRECTION_HORIZONTAL),\n                      multiply(\n                        this.gestureUntraversed,\n                        I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n                      ),\n                      this.gestureUntraversed\n                    ),\n                    this.distance\n                  ),\n                  TRUE_NODE\n                )\n              ),\n              FALSE_NODE\n            ),\n            TRUE_NODE\n          )\n        ),\n        // Stop animations while we're dragging\n        // and invoke proper listener\n        cond(\n          clockRunning(this.clock),\n          call([this.toValue], ([target]) => {\n            this.isRunningAnimation = false;\n            if (target) {\n              this.props.onOpen(false);\n            } else {\n              this.props.onClose(false);\n            }\n          })\n        ),\n        stopClock(this.clock),\n      ],\n      [\n        set(\n          this.isSwipeCancelled,\n          eq(this.gestureState, GestureState.CANCELLED)\n        ),\n        set(this.isSwiping, FALSE_NODE),\n        this.runTransition(\n          cond(\n            greaterThan(\n              abs(this.extrapolatedPosition),\n              divide(this.distance, 2)\n            ),\n            cond(\n              lessThan(\n                cond(\n                  eq(this.velocity, FALSE_NODE),\n                  this.gesture,\n                  this.velocity\n                ),\n                FALSE_NODE\n              ),\n              TRUE_NODE,\n              FALSE_NODE\n            ),\n            this.isVisible\n          )\n        ),\n      ]\n    ),\n  ]);\n\n  private handleGestureEventHorizontal = Animated.event([\n    {\n      nativeEvent: {\n        translationX: this.gestureUntraversed,\n        velocityX: this.velocityUntraversed,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private handleGestureEventVertical = Animated.event([\n    {\n      nativeEvent: {\n        translationY: this.gestureUntraversed,\n        velocityY: this.velocityUntraversed,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  // We need to ensure that this style doesn't change unless absolutely needs to\n  // Changing it too often will result in huge frame drops due to detaching and attaching\n  // Changing it during an animations can result in unexpected results\n  private getInterpolatedStyle = memoize(\n    (\n      styleInterpolator: CardStyleInterpolator,\n      index: number,\n      current: Animated.Node<number>,\n      next: Animated.Node<number> | undefined,\n      layout: Layout,\n      insetTop: number,\n      insetRight: number,\n      insetBottom: number,\n      insetLeft: number\n    ) =>\n      styleInterpolator({\n        index,\n        current: { progress: current },\n        next: next && { progress: next },\n        closing: this.isClosing,\n        layouts: {\n          screen: layout,\n        },\n        insets: {\n          top: insetTop,\n          right: insetRight,\n          bottom: insetBottom,\n          left: insetLeft,\n        },\n      })\n  );\n\n  // Keep track of the style in a property to avoid changing the animated node when deps change\n  // The style shouldn't change in the middle of the animation and should refer to what was there at the start of it\n  // Which will be the last value when just before the render which started the animation\n  // We need to make sure to update this when the running animation ends\n  private interpolatedStyle = this.getInterpolatedStyle(\n    this.props.styleInterpolator,\n    this.props.index,\n    this.props.current,\n    this.props.next,\n    this.props.layout,\n    this.props.insets.top,\n    this.props.insets.right,\n    this.props.insets.bottom,\n    this.props.insets.left\n  );\n\n  private gestureActivationCriteria() {\n    const { layout, gestureDirection, gestureResponseDistance } = this.props;\n\n    const distance =\n      gestureDirection === 'vertical' ||\n      gestureDirection === 'vertical-inverted'\n        ? gestureResponseDistance &&\n          gestureResponseDistance.vertical !== undefined\n          ? gestureResponseDistance.vertical\n          : GESTURE_RESPONSE_DISTANCE_VERTICAL\n        : gestureResponseDistance &&\n          gestureResponseDistance.horizontal !== undefined\n        ? gestureResponseDistance.horizontal\n        : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n    if (gestureDirection === 'vertical') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: 5,\n        hitSlop: { bottom: -layout.height + distance },\n      };\n    } else if (gestureDirection === 'vertical-inverted') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: -5,\n        hitSlop: { top: -layout.height + distance },\n      };\n    } else {\n      const hitSlop = -layout.width + distance;\n\n      if (I18nManager.isRTL) {\n        return {\n          minOffsetX: -5,\n          maxDeltaY: 20,\n          hitSlop: { left: hitSlop },\n        };\n      } else {\n        return {\n          minOffsetX: 5,\n          maxDeltaY: 20,\n          hitSlop: { right: hitSlop },\n        };\n      }\n    }\n  }\n\n  private gestureRef: React.Ref<PanGestureHandler> = React.createRef();\n\n  render() {\n    const {\n      active,\n      transparent,\n      styleInterpolator,\n      index,\n      current,\n      next,\n      layout,\n      insets,\n      overlayEnabled,\n      shadowEnabled,\n      gestureEnabled,\n      gestureDirection,\n      children,\n      containerStyle: customContainerStyle,\n      contentStyle,\n      ...rest\n    } = this.props;\n\n    if (!this.isRunningAnimation) {\n      this.interpolatedStyle = this.getInterpolatedStyle(\n        styleInterpolator,\n        index,\n        current,\n        next,\n        layout,\n        insets.top,\n        insets.right,\n        insets.bottom,\n        insets.left\n      );\n    }\n\n    const {\n      containerStyle,\n      cardStyle,\n      overlayStyle,\n      shadowStyle,\n      overlayBackgroundComponent\n    } = this.interpolatedStyle;\n\n    const handleGestureEvent = gestureEnabled\n      ? gestureDirection === 'vertical' ||\n        gestureDirection === 'vertical-inverted'\n        ? this.handleGestureEventVertical\n        : this.handleGestureEventHorizontal\n      : undefined;\n\n    let overrideFlex = null;\n    if (cardStyle) {\n      const style = StyleSheet.flatten(cardStyle) as ViewStyle;\n      if (style.hasOwnProperty('flex')) {\n        overrideFlex = { flex: style.flex };\n      }\n    }\n\n    return (\n      <StackGestureContext.Provider value={this.gestureRef}>\n        <View pointerEvents=\"box-none\" {...rest}>\n          <Animated.Code\n            key={gestureEnabled ? 'gesture-code' : 'no-gesture-code'}\n            exec={gestureEnabled ? this.execWithGesture : this.execNoGesture}\n          />\n          {overlayEnabled && overlayStyle ? (\n            <Animated.View\n              pointerEvents=\"none\"\n              style={[styles.overlay, overlayStyle]}\n            />\n          ) : null}\n\n          {overlayBackgroundComponent && overlayBackgroundComponent() }\n\n\n          <Animated.View\n            style={[styles.container, containerStyle, customContainerStyle]}\n            pointerEvents=\"box-none\"\n          >\n            <PanGestureHandler\n              ref={this.gestureRef}\n              enabled={layout.width !== 0 && gestureEnabled}\n              onGestureEvent={handleGestureEvent}\n              onHandlerStateChange={handleGestureEvent}\n              {...this.gestureActivationCriteria()}\n            >\n              <Animated.View style={[styles.container, cardStyle]}>\n                {shadowEnabled && shadowStyle && !transparent ? (\n                  <Animated.View\n                    style={[\n                      styles.shadow,\n                      gestureDirection === 'horizontal'\n                        ? styles.shadowHorizontal\n                        : styles.shadowVertical,\n                      shadowStyle,\n                    ]}\n                    pointerEvents=\"none\"\n                  />\n                ) : null}\n                <PointerEventsView\n                  active={active}\n                  progress={this.props.current}\n                  style={[\n                    styles.content,\n                    overrideFlex,\n                    transparent ? styles.transparent : styles.opaque,\n                    contentStyle,\n                  ]}\n                >\n                  {children}\n                </PointerEventsView>\n              </Animated.View>\n            </PanGestureHandler>\n          </Animated.View>\n        </View>\n      </StackGestureContext.Provider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: '#000',\n  },\n  shadow: {\n    position: 'absolute',\n    backgroundColor: '#fff',\n    shadowRadius: 5,\n    shadowColor: '#000',\n    shadowOpacity: 0.3,\n  },\n  shadowHorizontal: {\n    top: 0,\n    left: 0,\n    bottom: 0,\n    width: 3,\n    shadowOffset: { width: -1, height: 1 },\n  },\n  shadowVertical: {\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 3,\n    shadowOffset: { width: 1, height: -1 },\n  },\n  transparent: {\n    backgroundColor: 'transparent',\n  },\n  opaque: {\n    backgroundColor: '#eee',\n  },\n});\n"]}