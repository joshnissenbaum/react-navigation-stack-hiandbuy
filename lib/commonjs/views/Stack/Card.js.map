{"version":3,"sources":["Card.tsx"],"names":["TRUE","TRUE_NODE","Animated","Value","FALSE","FALSE_NODE","NOOP_NODE","UNSET","UNSET_NODE","MINUS_ONE_NODE","TOP","BOTTOM","DIRECTION_VERTICAL","DIRECTION_HORIZONTAL","GESTURE_VELOCITY_IMPACT","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","abs","add","block","call","cond","divide","eq","greaterThan","lessThan","max","min","multiply","neq","onChange","set","spring","sub","timing","startClock","stopClock","clockRunning","Clock","memoizedSpring","proc","springHelper","finished","velocity","position","time","prevPosition","toValue","damping","mass","stiffness","overshootClamping","restSpeedThreshold","restDisplacementThreshold","clock","state","config","transformSpringConfigToAnimatedValues","transformTimingConfigToAnimatedValues","duration","easing","Card","React","Component","props","gestureDirection","width","layout","height","gestureVelocityImpact","transitionSpec","open","animation","close","direction","current","interactionHandle","undefined","InteractionManager","createInteractionHandle","clearInteractionHandle","handleEndInteraction","isRunningAnimation","interpolatedStyle","getInterpolatedStyle","styleInterpolator","index","next","insets","top","right","bottom","left","isVisible","openingSpec","closingSpec","didMovementHappen","handleStartInteraction","onTransitionStart","closing","handleTransitionEnd","onOpen","transitionVelocity","distance","frameTime","transitionState","value","noAnimationStartedSoFar","openingSpecConfig","closingSpecConfig","isSwipeGesture","gesture","isOpen","Boolean","onClose","gestureUntraversed","I18nManager","isRTL","velocityUntraversed","isClosing","nextIsVisible","exec","runTransition","isSwiping","isSwipeCancelled","onGestureBegin","onGestureEnd","onGestureCanceled","gestureState","GestureState","ACTIVE","offset","target","CANCELLED","extrapolatedPosition","event","nativeEvent","translationX","velocityX","translationY","velocityY","insetTop","insetRight","insetBottom","insetLeft","progress","layouts","screen","createRef","componentDidUpdate","prevProps","setValue","verticalGestureDirection","requestAnimationFrame","componentWillUnmount","gestureActivationCriteria","gestureResponseDistance","vertical","horizontal","maxDeltaX","minOffsetY","hitSlop","minOffsetX","maxDeltaY","render","active","transparent","overlayEnabled","shadowEnabled","gestureEnabled","children","containerStyle","customContainerStyle","contentStyle","rest","cardStyle","overlayStyle","shadowStyle","overlayBackgroundComponent","handleGestureEvent","handleGestureEventVertical","handleGestureEventHorizontal","overrideFlex","style","StyleSheet","flatten","hasOwnProperty","flex","gestureRef","execWithGesture","execNoGesture","styles","overlay","container","shadow","shadowHorizontal","shadowVertical","content","opaque","Platform","OS","create","overflow","absoluteFillObject","backgroundColor","shadowRadius","shadowColor","shadowOpacity","shadowOffset"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  View,\n  I18nManager,\n  StyleSheet,\n  ViewProps,\n  StyleProp,\n  ViewStyle,\n  Platform,\n  InteractionManager,\n} from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport {\n  PanGestureHandler,\n  State as GestureState,\n} from 'react-native-gesture-handler';\nimport { EdgeInsets } from 'react-native-safe-area-context';\nimport {\n  TransitionSpec,\n  CardStyleInterpolator,\n  Layout,\n  SpringConfig,\n  TimingConfig,\n} from '../../types';\nimport memoize from '../../utils/memoize';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport PointerEventsView from './PointerEventsView';\n\ntype Props = ViewProps & {\n  index: number;\n  active: boolean;\n  closing?: boolean;\n  transparent?: boolean;\n  next?: Animated.Node<number>;\n  current: Animated.Value<number>;\n  layout: Layout;\n  insets: EdgeInsets;\n  gestureDirection: 'horizontal' | 'vertical' | 'vertical-inverted';\n  onOpen: (isFinished: boolean) => void;\n  onClose: (isFinished: boolean) => void;\n  onTransitionStart?: (props: { closing: boolean }) => void;\n  onGestureBegin?: () => void;\n  onGestureCanceled?: () => void;\n  onGestureEnd?: () => void;\n  children: React.ReactNode;\n  overlayEnabled: boolean;\n  shadowEnabled: boolean;\n  gestureEnabled: boolean;\n  gestureResponseDistance?: {\n    vertical?: number;\n    horizontal?: number;\n  };\n  transitionSpec: {\n    open: TransitionSpec;\n    close: TransitionSpec;\n  };\n  styleInterpolator: CardStyleInterpolator;\n  gestureVelocityImpact: number;\n  containerStyle?: StyleProp<ViewStyle>;\n  contentStyle?: StyleProp<ViewStyle>;\n};\n\ntype AnimatedSpringConfig = {\n  damping: Animated.Value<number>;\n  mass: Animated.Value<number>;\n  stiffness: Animated.Value<number>;\n  restSpeedThreshold: Animated.Value<number>;\n  restDisplacementThreshold: Animated.Value<number>;\n  overshootClamping: Animated.Value<boolean>;\n};\n\nexport type AnimatedTimingConfig = {\n  duration: Animated.Value<number>;\n  easing: Animated.EasingFunction;\n};\n\ntype Binary = 0 | 1;\n\nconst TRUE = 1;\nconst TRUE_NODE = new Animated.Value(TRUE);\nconst FALSE = 0;\nconst FALSE_NODE = new Animated.Value(FALSE);\nconst NOOP_NODE = FALSE_NODE;\nconst UNSET = -1;\nconst UNSET_NODE = new Animated.Value(UNSET);\n\nconst MINUS_ONE_NODE = UNSET_NODE;\n\nconst TOP = -1;\nconst BOTTOM = 1;\n\nconst DIRECTION_VERTICAL = -1;\nconst DIRECTION_HORIZONTAL = 1;\n\nconst GESTURE_VELOCITY_IMPACT = 0.3;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst {\n  abs,\n  add,\n  block,\n  call,\n  cond,\n  divide,\n  eq,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  onChange,\n  set,\n  spring,\n  sub,\n  timing,\n  startClock,\n  stopClock,\n  clockRunning,\n  Clock,\n  Value,\n} = Animated;\n\n// We need to be prepared for both version of reanimated. With and w/out proc\nlet memoizedSpring = spring;\n// @ts-ignore\nif (Animated.proc) {\n  // @ts-ignore\n  const springHelper = Animated.proc(\n    (\n      finished: Animated.Value<number>,\n      velocity: Animated.Value<number>,\n      position: Animated.Value<number>,\n      time: Animated.Value<number>,\n      prevPosition: Animated.Value<number>,\n      toValue: Animated.Adaptable<number>,\n      damping: Animated.Adaptable<number>,\n      mass: Animated.Adaptable<number>,\n      stiffness: Animated.Adaptable<number>,\n      overshootClamping: Animated.Adaptable<boolean>,\n      restSpeedThreshold: Animated.Adaptable<number>,\n      restDisplacementThreshold: Animated.Adaptable<number>,\n      clock: Animated.Clock\n    ) =>\n      spring(\n        clock,\n        {\n          finished,\n          velocity,\n          position,\n          time,\n          // @ts-ignore\n          prevPosition,\n        },\n        {\n          toValue,\n          damping,\n          mass,\n          stiffness,\n          overshootClamping,\n          restDisplacementThreshold,\n          restSpeedThreshold,\n        }\n      )\n  );\n\n  // @ts-ignore\n  memoizedSpring = function(\n    clock: Animated.Clock,\n    state: {\n      finished: Animated.Value<number>;\n      velocity: Animated.Value<number>;\n      position: Animated.Value<number>;\n      time: Animated.Value<number>;\n    },\n    config: {\n      toValue: Animated.Adaptable<number>;\n      damping: Animated.Adaptable<number>;\n      mass: Animated.Adaptable<number>;\n      stiffness: Animated.Adaptable<number>;\n      overshootClamping: Animated.Adaptable<boolean>;\n      restSpeedThreshold: Animated.Adaptable<number>;\n      restDisplacementThreshold: Animated.Adaptable<number>;\n    }\n  ) {\n    return springHelper(\n      state.finished,\n      state.velocity,\n      state.position,\n      state.time,\n      new Value(0),\n      config.toValue,\n      config.damping,\n      config.mass,\n      config.stiffness,\n      config.overshootClamping,\n      config.restSpeedThreshold,\n      config.restDisplacementThreshold,\n      clock\n    );\n  };\n}\n\nfunction transformSpringConfigToAnimatedValues(\n  config: SpringConfig\n): AnimatedSpringConfig {\n  return {\n    damping: new Animated.Value(config.damping),\n    stiffness: new Animated.Value(config.stiffness),\n    mass: new Animated.Value(config.mass),\n    restDisplacementThreshold: new Animated.Value(\n      config.restDisplacementThreshold\n    ),\n    restSpeedThreshold: new Animated.Value(config.restSpeedThreshold),\n    overshootClamping: new Animated.Value(config.overshootClamping),\n  };\n}\n\nfunction transformTimingConfigToAnimatedValues(\n  config: TimingConfig\n): AnimatedTimingConfig {\n  return {\n    duration: new Animated.Value(config.duration),\n    easing: config.easing,\n  };\n}\n\nexport default class Card extends React.Component<Props> {\n  static defaultProps = {\n    overlayEnabled: Platform.OS !== 'ios',\n    shadowEnabled: true,\n    gestureEnabled: true,\n    gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,\n  };\n\n  componentDidUpdate(prevProps: Props) {\n    const {\n      layout,\n      gestureDirection,\n      closing,\n      gestureVelocityImpact,\n    } = this.props;\n    const { width, height } = layout;\n\n    if (width !== prevProps.layout.width) {\n      this.layout.width.setValue(width);\n    }\n\n    if (height !== prevProps.layout.height) {\n      this.layout.height.setValue(height);\n    }\n\n    if (gestureVelocityImpact !== prevProps.gestureVelocityImpact) {\n      this.gestureVelocityImpact.setValue(gestureVelocityImpact);\n    }\n\n    if (gestureDirection !== prevProps.gestureDirection) {\n      this.direction.setValue(\n        gestureDirection === 'vertical' ||\n          gestureDirection === 'vertical-inverted'\n          ? DIRECTION_VERTICAL\n          : DIRECTION_HORIZONTAL\n      );\n      this.verticalGestureDirection.setValue(\n        gestureDirection === 'vertical-inverted' ? TOP : BOTTOM\n      );\n    }\n\n    if (closing !== prevProps.closing) {\n      // If the style updates during render, setting the value here doesn't work\n      // We need to defer it a bit so the animation starts properly\n      requestAnimationFrame(() =>\n        requestAnimationFrame(() =>\n          this.isClosing.setValue(closing ? TRUE : FALSE)\n        )\n      );\n    }\n  }\n\n  componentWillUnmount(): void {\n    this.handleEndInteraction();\n\n    // It might sometimes happen than animation will be unmounted\n    // during running. However, we need to invoke listener onClose\n    // manually in this case\n    if (this.isRunningAnimation || this.noAnimationStartedSoFar) {\n      this.props.onClose(false);\n    }\n  }\n\n  private isVisible = new Value<Binary>(TRUE);\n  private nextIsVisible = new Value<Binary | -1>(UNSET);\n\n  private verticalGestureDirection = new Value(\n    this.props.gestureDirection === 'vertical-inverted' ? TOP : BOTTOM\n  );\n\n  private isClosing = new Value<Binary>(FALSE);\n  private noAnimationStartedSoFar = true;\n  private isRunningAnimation = false;\n\n  private clock = new Clock();\n\n  private direction = new Value(\n    this.props.gestureDirection === 'vertical' ||\n    this.props.gestureDirection === 'vertical-inverted'\n      ? DIRECTION_VERTICAL\n      : DIRECTION_HORIZONTAL\n  );\n\n  private layout = {\n    width: new Value(this.props.layout.width),\n    height: new Value(this.props.layout.height),\n  };\n\n  private gestureVelocityImpact = new Value<number>(\n    this.props.gestureVelocityImpact\n  );\n\n  private openingSpecConfig =\n    this.props.transitionSpec.open.animation === 'timing'\n      ? transformTimingConfigToAnimatedValues(\n          this.props.transitionSpec.open.config\n        )\n      : transformSpringConfigToAnimatedValues(\n          this.props.transitionSpec.open.config\n        );\n\n  private closingSpecConfig =\n    this.props.transitionSpec.close.animation === 'timing'\n      ? transformTimingConfigToAnimatedValues(\n          this.props.transitionSpec.close.config\n        )\n      : transformSpringConfigToAnimatedValues(\n          this.props.transitionSpec.close.config\n        );\n\n  private distance = cond(\n    eq(this.direction, DIRECTION_VERTICAL),\n    this.layout.height,\n    this.layout.width\n  );\n\n  private gestureUntraversed = new Value(0);\n  private gesture = new Value(0);\n  private offset = new Value(0);\n  private velocityUntraversed = new Value(0);\n  private velocity = new Value(0);\n  private didMovementHappen = new Value(0);\n\n  private gestureState = new Value(0);\n\n  private isSwiping = new Value(FALSE);\n  private isSwipeCancelled = new Value(FALSE);\n  private isSwipeGesture = new Value(FALSE);\n\n  private toValue = new Value(0);\n  private frameTime = new Value(0);\n\n  private transitionVelocity = new Value(0);\n\n  private transitionState = {\n    position: this.props.current,\n    time: new Value(0),\n    finished: new Value(FALSE),\n  };\n\n  private interactionHandle: number | undefined;\n\n  private handleStartInteraction = () => {\n    if (this.interactionHandle === undefined) {\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    }\n  };\n\n  private handleEndInteraction = () => {\n    if (this.interactionHandle !== undefined) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n      this.interactionHandle = undefined;\n    }\n  };\n\n  private handleTransitionEnd = () => {\n    this.handleEndInteraction();\n\n    this.isRunningAnimation = false;\n    this.interpolatedStyle = this.getInterpolatedStyle(\n      this.props.styleInterpolator,\n      this.props.index,\n      this.props.current,\n      this.props.next,\n      this.props.layout,\n      this.props.insets.top,\n      this.props.insets.right,\n      this.props.insets.bottom,\n      this.props.insets.left\n    );\n  };\n\n  private runTransition = (isVisible: Binary | Animated.Node<number>) => {\n    const { open: openingSpec, close: closingSpec } = this.props.transitionSpec;\n\n    return [\n      cond(\n        eq(this.props.current, isVisible),\n        call(\n          [this.didMovementHappen, this.isVisible],\n          ([didMovementHappen]: ReadonlyArray<Binary>) => {\n            if (didMovementHappen) {\n              // if we go back to the same position,\n              // let's pretend that whole animation happen\n              // for making the logic consistent\n              // It's especially vital for having inputs properly focused.\n              this.handleStartInteraction();\n              const { onTransitionStart } = this.props;\n              onTransitionStart && onTransitionStart({ closing: false });\n              this.handleTransitionEnd();\n              this.props.onOpen(true);\n            }\n          }\n        ),\n        [\n          cond(clockRunning(this.clock), NOOP_NODE, [\n            // Animation wasn't running before\n            // Set the initial values and start the clock\n            set(this.toValue, isVisible),\n            // The velocity value is ideal for translating the whole screen\n            // But since we have 0-1 scale, we need to adjust the velocity\n            set(\n              this.transitionVelocity,\n              multiply(\n                cond(\n                  this.distance,\n                  divide(this.velocity, this.distance),\n                  FALSE_NODE\n                ),\n                -1\n              )\n            ),\n            set(this.frameTime, FALSE_NODE),\n            set(this.transitionState.time, FALSE_NODE),\n            set(this.transitionState.finished, FALSE_NODE),\n            set(this.isVisible, isVisible),\n            startClock(this.clock),\n            call([this.isVisible], ([value]: ReadonlyArray<Binary>) => {\n              this.handleStartInteraction();\n\n              const { onTransitionStart } = this.props;\n              this.noAnimationStartedSoFar = false;\n              this.isRunningAnimation = true;\n              onTransitionStart && onTransitionStart({ closing: !value });\n            }),\n          ]),\n          cond(\n            eq(isVisible, TRUE_NODE),\n            openingSpec.animation === 'spring'\n              ? memoizedSpring(\n                  this.clock,\n                  {\n                    ...this.transitionState,\n                    velocity: this.transitionVelocity,\n                  },\n                  // @ts-ignore\n                  {\n                    ...(this.openingSpecConfig as AnimatedSpringConfig),\n                    toValue: this.toValue,\n                  }\n                )\n              : timing(\n                  this.clock,\n                  { ...this.transitionState, frameTime: this.frameTime },\n                  {\n                    ...(this.openingSpecConfig as AnimatedTimingConfig),\n                    toValue: this.toValue,\n                  }\n                ),\n            closingSpec.animation === 'spring'\n              ? memoizedSpring(\n                  this.clock,\n                  {\n                    ...this.transitionState,\n                    velocity: this.transitionVelocity,\n                  },\n                  // @ts-ignore\n                  {\n                    ...(this.closingSpecConfig as AnimatedSpringConfig),\n                    toValue: this.toValue,\n                  }\n                )\n              : timing(\n                  this.clock,\n                  { ...this.transitionState, frameTime: this.frameTime },\n                  {\n                    ...(this.closingSpecConfig as AnimatedTimingConfig),\n                    toValue: this.toValue,\n                  }\n                )\n          ),\n          cond(this.transitionState.finished, [\n            // Reset values\n            set(this.isSwipeGesture, FALSE_NODE),\n            set(this.gesture, FALSE_NODE),\n            set(this.velocity, FALSE_NODE),\n            // When the animation finishes, stop the clock\n            stopClock(this.clock),\n            call([this.isVisible], ([value]: ReadonlyArray<Binary>) => {\n              const isOpen = Boolean(value);\n              const { onOpen, onClose } = this.props;\n\n              this.handleTransitionEnd();\n\n              if (isOpen) {\n                onOpen(true);\n              } else {\n                onClose(true);\n              }\n            }),\n          ]),\n        ]\n      ),\n      set(this.didMovementHappen, 0),\n    ];\n  };\n\n  private extrapolatedPosition = add(\n    this.gesture,\n    multiply(this.velocity, this.gestureVelocityImpact)\n  );\n\n  private exec = [\n    set(\n      this.gesture,\n      cond(\n        eq(this.direction, DIRECTION_HORIZONTAL),\n        multiply(\n          this.gestureUntraversed,\n          I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n        ),\n        this.gestureUntraversed\n      )\n    ),\n    set(\n      this.velocity,\n      multiply(\n        this.velocityUntraversed,\n        I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n      )\n    ),\n    onChange(\n      this.isClosing,\n      cond(this.isClosing, set(this.nextIsVisible, FALSE_NODE))\n    ),\n    onChange(\n      this.nextIsVisible,\n      cond(neq(this.nextIsVisible, UNSET_NODE), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), [\n          call([], this.handleTransitionEnd),\n          stopClock(this.clock),\n        ]),\n        set(this.gesture, FALSE_NODE),\n        // Update the index to trigger the transition\n        set(this.isVisible, this.nextIsVisible),\n        set(this.nextIsVisible, UNSET_NODE),\n      ])\n    ),\n  ];\n\n  private execNoGesture = block([\n    ...this.exec,\n    this.runTransition(this.isVisible),\n  ]);\n\n  private execWithGesture = block([\n    ...this.exec,\n    onChange(\n      this.isSwiping,\n      call(\n        [this.isSwiping, this.isSwipeCancelled],\n        ([isSwiping, isSwipeCancelled]: readonly Binary[]) => {\n          const {\n            onGestureBegin,\n            onGestureEnd,\n            onGestureCanceled,\n          } = this.props;\n\n          if (isSwiping === TRUE) {\n            this.handleStartInteraction();\n\n            onGestureBegin && onGestureBegin();\n          } else {\n            this.handleEndInteraction();\n\n            if (isSwipeCancelled === TRUE) {\n              onGestureCanceled && onGestureCanceled();\n            } else {\n              onGestureEnd && onGestureEnd();\n            }\n          }\n        }\n      )\n    ),\n    onChange(this.gestureUntraversed, set(this.didMovementHappen, 1)),\n    cond(\n      eq(this.gestureState, GestureState.ACTIVE),\n      [\n        cond(this.isSwiping, NOOP_NODE, [\n          // We weren't dragging before, set it to true\n          set(this.isSwipeCancelled, FALSE_NODE),\n          set(this.isSwiping, TRUE_NODE),\n          set(this.isSwipeGesture, TRUE_NODE),\n          // Also update the drag offset to the last position\n          set(this.offset, this.props.current),\n        ]),\n        // Update position with next offset + gesture distance\n        set(\n          this.props.current,\n          min(\n            max(\n              sub(\n                this.offset,\n                cond(\n                  this.distance,\n                  divide(\n                    cond(\n                      eq(this.direction, DIRECTION_HORIZONTAL),\n                      multiply(\n                        this.gestureUntraversed,\n                        I18nManager.isRTL ? MINUS_ONE_NODE : TRUE_NODE\n                      ),\n                      this.gestureUntraversed\n                    ),\n                    this.distance\n                  ),\n                  TRUE_NODE\n                )\n              ),\n              FALSE_NODE\n            ),\n            TRUE_NODE\n          )\n        ),\n        // Stop animations while we're dragging\n        // and invoke proper listener\n        cond(\n          clockRunning(this.clock),\n          call([this.toValue], ([target]) => {\n            this.isRunningAnimation = false;\n            if (target) {\n              this.props.onOpen(false);\n            } else {\n              this.props.onClose(false);\n            }\n          })\n        ),\n        stopClock(this.clock),\n      ],\n      [\n        set(\n          this.isSwipeCancelled,\n          eq(this.gestureState, GestureState.CANCELLED)\n        ),\n        set(this.isSwiping, FALSE_NODE),\n        this.runTransition(\n          cond(\n            greaterThan(\n              abs(this.extrapolatedPosition),\n              divide(this.distance, 2)\n            ),\n            cond(\n              lessThan(\n                cond(\n                  eq(this.velocity, FALSE_NODE),\n                  this.gesture,\n                  this.velocity\n                ),\n                FALSE_NODE\n              ),\n              TRUE_NODE,\n              FALSE_NODE\n            ),\n            this.isVisible\n          )\n        ),\n      ]\n    ),\n  ]);\n\n  private handleGestureEventHorizontal = Animated.event([\n    {\n      nativeEvent: {\n        translationX: this.gestureUntraversed,\n        velocityX: this.velocityUntraversed,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private handleGestureEventVertical = Animated.event([\n    {\n      nativeEvent: {\n        translationY: this.gestureUntraversed,\n        velocityY: this.velocityUntraversed,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  // We need to ensure that this style doesn't change unless absolutely needs to\n  // Changing it too often will result in huge frame drops due to detaching and attaching\n  // Changing it during an animations can result in unexpected results\n  private getInterpolatedStyle = memoize(\n    (\n      styleInterpolator: CardStyleInterpolator,\n      index: number,\n      current: Animated.Node<number>,\n      next: Animated.Node<number> | undefined,\n      layout: Layout,\n      insetTop: number,\n      insetRight: number,\n      insetBottom: number,\n      insetLeft: number\n    ) =>\n      styleInterpolator({\n        index,\n        current: { progress: current },\n        next: next && { progress: next },\n        closing: this.isClosing,\n        layouts: {\n          screen: layout,\n        },\n        insets: {\n          top: insetTop,\n          right: insetRight,\n          bottom: insetBottom,\n          left: insetLeft,\n        },\n      })\n  );\n\n  // Keep track of the style in a property to avoid changing the animated node when deps change\n  // The style shouldn't change in the middle of the animation and should refer to what was there at the start of it\n  // Which will be the last value when just before the render which started the animation\n  // We need to make sure to update this when the running animation ends\n  private interpolatedStyle = this.getInterpolatedStyle(\n    this.props.styleInterpolator,\n    this.props.index,\n    this.props.current,\n    this.props.next,\n    this.props.layout,\n    this.props.insets.top,\n    this.props.insets.right,\n    this.props.insets.bottom,\n    this.props.insets.left\n  );\n\n  private gestureActivationCriteria() {\n    const { layout, gestureDirection, gestureResponseDistance } = this.props;\n\n    const distance =\n      gestureDirection === 'vertical' ||\n      gestureDirection === 'vertical-inverted'\n        ? gestureResponseDistance &&\n          gestureResponseDistance.vertical !== undefined\n          ? gestureResponseDistance.vertical\n          : GESTURE_RESPONSE_DISTANCE_VERTICAL\n        : gestureResponseDistance &&\n          gestureResponseDistance.horizontal !== undefined\n        ? gestureResponseDistance.horizontal\n        : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n    if (gestureDirection === 'vertical') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: 5,\n        hitSlop: { bottom: -layout.height + distance },\n      };\n    } else if (gestureDirection === 'vertical-inverted') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: -5,\n        hitSlop: { top: -layout.height + distance },\n      };\n    } else {\n      const hitSlop = -layout.width + distance;\n\n      if (I18nManager.isRTL) {\n        return {\n          minOffsetX: -5,\n          maxDeltaY: 20,\n          hitSlop: { left: hitSlop },\n        };\n      } else {\n        return {\n          minOffsetX: 5,\n          maxDeltaY: 20,\n          hitSlop: { right: hitSlop },\n        };\n      }\n    }\n  }\n\n  private gestureRef: React.Ref<PanGestureHandler> = React.createRef();\n\n  render() {\n    const {\n      active,\n      transparent,\n      styleInterpolator,\n      index,\n      current,\n      next,\n      layout,\n      insets,\n      overlayEnabled,\n      shadowEnabled,\n      gestureEnabled,\n      gestureDirection,\n      children,\n      containerStyle: customContainerStyle,\n      contentStyle,\n      ...rest\n    } = this.props;\n\n    if (!this.isRunningAnimation) {\n      this.interpolatedStyle = this.getInterpolatedStyle(\n        styleInterpolator,\n        index,\n        current,\n        next,\n        layout,\n        insets.top,\n        insets.right,\n        insets.bottom,\n        insets.left\n      );\n    }\n\n    const {\n      containerStyle,\n      cardStyle,\n      overlayStyle,\n      shadowStyle,\n      overlayBackgroundComponent\n    } = this.interpolatedStyle;\n\n    const handleGestureEvent = gestureEnabled\n      ? gestureDirection === 'vertical' ||\n        gestureDirection === 'vertical-inverted'\n        ? this.handleGestureEventVertical\n        : this.handleGestureEventHorizontal\n      : undefined;\n\n    let overrideFlex = null;\n    if (cardStyle) {\n      const style = StyleSheet.flatten(cardStyle) as ViewStyle;\n      if (style.hasOwnProperty('flex')) {\n        overrideFlex = { flex: style.flex };\n      }\n    }\n\n    return (\n      <StackGestureContext.Provider value={this.gestureRef}>\n        <View pointerEvents=\"box-none\" {...rest}>\n          <Animated.Code\n            key={gestureEnabled ? 'gesture-code' : 'no-gesture-code'}\n            exec={gestureEnabled ? this.execWithGesture : this.execNoGesture}\n          />\n          {overlayEnabled && overlayStyle ? (\n            <Animated.View\n              pointerEvents=\"none\"\n              style={[styles.overlay, overlayStyle]}\n            />\n          ) : null}\n\n          {overlayBackgroundComponent && overlayBackgroundComponent() }\n\n\n          <Animated.View\n            style={[styles.container, containerStyle, customContainerStyle]}\n            pointerEvents=\"box-none\"\n          >\n            <PanGestureHandler\n              ref={this.gestureRef}\n              enabled={layout.width !== 0 && gestureEnabled}\n              onGestureEvent={handleGestureEvent}\n              onHandlerStateChange={handleGestureEvent}\n              {...this.gestureActivationCriteria()}\n            >\n              <Animated.View style={[styles.container, cardStyle]}>\n                {shadowEnabled && shadowStyle && !transparent ? (\n                  <Animated.View\n                    style={[\n                      styles.shadow,\n                      gestureDirection === 'horizontal'\n                        ? styles.shadowHorizontal\n                        : styles.shadowVertical,\n                      shadowStyle,\n                    ]}\n                    pointerEvents=\"none\"\n                  />\n                ) : null}\n                <PointerEventsView\n                  active={active}\n                  progress={this.props.current}\n                  style={[\n                    styles.content,\n                    overrideFlex,\n                    transparent ? styles.transparent : styles.opaque,\n                    contentStyle,\n                  ]}\n                >\n                  {children}\n                </PointerEventsView>\n              </Animated.View>\n            </PanGestureHandler>\n          </Animated.View>\n        </View>\n      </StackGestureContext.Provider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: '#000',\n  },\n  shadow: {\n    position: 'absolute',\n    backgroundColor: '#fff',\n    shadowRadius: 5,\n    shadowColor: '#000',\n    shadowOpacity: 0.3,\n  },\n  shadowHorizontal: {\n    top: 0,\n    left: 0,\n    bottom: 0,\n    width: 3,\n    shadowOffset: { width: -1, height: 1 },\n  },\n  shadowVertical: {\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 3,\n    shadowOffset: { width: 1, height: -1 },\n  },\n  transparent: {\n    backgroundColor: 'transparent',\n  },\n  opaque: {\n    backgroundColor: '#eee',\n  },\n});\n"]}